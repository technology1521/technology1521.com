---
layout:  single
title:  "kubernetes二进制安装高可用 - V1.20"
date:   2023-05-24 
categories:   [kubernetes]
classes: wide
---



## 一，基础环境分配

```shell
192.168.1.20 #hostnamectl set-hostname k8s-master1
192.168.1.21 #k8s-node1
192.168.1.22 #k8s-node2

192.168.1.20 #etcd
192.168.1.21 #etcd
192.168.1.22 #etcd

192.168.1.20 	#cfssl生成证书
以上机器都是2c3G
以上机器有重复利用，机器多可以分开布置
替换相应的IP即可
```

## 二，基础环境部署

### 2.1 关闭selinux/firewalld设置

#### 2.1.1 临时关闭

``` shell 
systemctl stop firewalld #临时关闭firewalld
setenforce 0 #临时关闭

```

#### 2.1.2 永久关闭

```shell
systemctl disable firewalld #永久关闭firewalld

vi  /etc/selinux/config #永久关闭SElinux

SELINUX=disable


```

### 2.2 关闭swap

2.2.1 临时关闭

```shell
swapoff -a #第一步 关闭swap分区
vi  /etc/fstab
 /dev/mapper/centos-swap swap defaults 0 0 #注释此行
 #/dev/mapper/centos-swap swap                    swap    defaults        0 0

free -m #查看是否关闭 若swap行都显示 0 则表示关闭成功
```



2.2.2 永久关闭

```shell
vim /etc/sysctl.conf # 永久生效
修改 vm.swappiness 的修改为 0
vm.swappiness=0
sysctl -p # 使配置生效
vi  /etc/fstab
 /dev/mapper/centos-swap swap defaults 0 0 #注释此行
 #/dev/mapper/centos-swap swap                    swap    defaults        0 0
 ##重启init 6
```

或者

```shell
#关闭swap
swapoff -a  # 临时 
sed -ri 's/.*swap.*/#&/' /etc/fstab    # 永久
```

这里要永久关闭selinux、firewalld，swap

### 2.3修改主机名、加域名解析

#### 2.3.1 修改主机名

```shell
192.168.1.20
hostnamectl set-hostname k8s-master1
192.168.1.21
hostnamectl set-hostname k8s-node1
192.168.1.22
hostnamectl set-hostname k8s-node2
192.168.1.23
hostnamectl set-hostname k8s-master2
```

#### 2.3.2 加域名解析

```shell
##所有机器192.168.1.20-23 
vim /etc/hosts

192.168.1.20 k8s-master1
192.168.1.21 k8s-node1
192.168.1.22 k8s-node2
192.168.1.23 k8s-master2
```

#### 2.3.3做流量转发

```shell
# 将桥接的IPv4流量传递到iptables的链 
vim /etc/sysctl.d/k8s.conf 
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1

sysctl --system  # 生效
```

## 三 ，部署Etcd集群

### 3.1 准备cfssl证书生成工具

cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl更方便使用。

文件：[cfssl](https://technology1521.github.io/technology1521.com/soft/cfssl)

[cfssljson](https://technology1521.github.io/technology1521.com/soft/cfssljson)

[cfssl-certinfo](https://technology1521.github.io/technology1521.com/soft/cfssl-certinfo)

```shell
可以是任意一台机器，但是要注意IP或域名的变动
这里选择 192.168.1.23 k8s-master2 这台机器


wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64

chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64 #赋权
mv cfssl_linux-amd64 /usr/local/bin/cfssl
mv cfssljson_linux-amd64 /usr/local/bin/cfssljson
mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo #移动


```

### 3.2、生成Etcd证书

```shell
-------------------------master1节点------------------------
1)自签证书颁发机构（CA）

#创建目录
[root@k8s-master2 ~]# mkdir -p ca/etcd
[root@k8s-master2 ~]# cd ca/etcd

#自签CA
[root@k8s-master2 etcd]# vim ca-config.json
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "www": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}

[root@k8s-master1 etcd]# vim ca-csr.json
{
    "CN": "etcd CA",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Beijing",
            "ST": "Beijing"
        }
    ]
}

#生成证书
[root@k8s-master1 etcd]# cfssl gencert -initca ca-csr.json | cfssljson -bare ca -


2)使用自签CA签发Etcd HTTPS证书

#创建证书申请文件
[root@k8s-master1 etcd]# vim server-csr.json
{
    "CN": "etcd",
    "hosts": [
    "192.168.1.20",
    "192.168.1.21",
    "192.168.1.22"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "BeiJing",
            "ST": "BeiJing"
        }
    ]
}

*注：上述文件hosts字段中IP为所有etcd节点的集群内部通信IP，一个都不能少！为了方便后期扩容可以多写几个预留的IP

#生成证书
[root@k8s-master1 etcd]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server




```

### 3.3、部署Etcd集群

```shell
-------------------------master1节点------------------------

#创建工作目录并解压二进制包
[root@k8s-master1 ~]# mkdir -p /opt/etcd/{bin,cfg,ssl}
[root@k8s-master1 ~]# tar zxvf etcd-v3.4.9-linux-amd64.tar.gz
[root@k8s-master1 ~]# mv etcd-v3.4.9-linux-amd64/{etcd,etcdctl} /opt/etcd/bin/

#创建etcd配置文件
[root@k8s-master1 ~]# vim /opt/etcd/cfg/etcd.conf
#[Member]
ETCD_NAME="etcd-1"
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://192.168.1.20:2380"
ETCD_LISTEN_CLIENT_URLS="https://192.168.1.20:2379"

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.1.20:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.1.20:2379"
ETCD_INITIAL_CLUSTER="etcd-1=https://192.168.1.20:2380,etcd-2=https://192.168.1.21:2380,etcd-3=https://192.168.1.22:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"


*参数解释
•	ETCD_NAME：节点名称，集群中唯一
•	ETCD_DATA_DIR：数据目录
•	ETCD_LISTEN_PEER_URLS：集群通信监听地址
•	ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址
•	ETCD_INITIAL_ADVERTISE_PEERURLS：集群通告地址
•	ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址
•	ETCD_INITIAL_CLUSTER：集群节点地址
•	ETCD_INITIALCLUSTER_TOKEN：集群Token
•	ETCD_INITIALCLUSTER_STATE：加入集群的当前状态，new是新集群，existing表示加入已有集群


#systemd管理etcd
[root@k8s-master1 ~]# vim /usr/lib/systemd/system/etcd.service

###############etcd-v3.4.9
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
EnvironmentFile=/opt/etcd/cfg/etcd.conf
ExecStart=/opt/etcd/bin/etcd \
--cert-file=/opt/etcd/ssl/server.pem \
--key-file=/opt/etcd/ssl/server-key.pem \
--peer-cert-file=/opt/etcd/ssl/server.pem \
--peer-key-file=/opt/etcd/ssl/server-key.pem \
--trusted-ca-file=/opt/etcd/ssl/ca.pem \
--peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \
--logger=zap                                  ##########etcd-v3.2.12删除这句
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target


#拷贝刚才生成的证书
[root@k8s-master1 ~]# cp ~/ca/etcd/*.pem /opt/etcd/ssl


#将上面Master节点所有生成的文件拷贝到节点Node2和节点Node3上
[root@k8s-master1 ~]# scp -r /opt/etcd/ k8s-node1:/opt/
[root@k8s-master1 ~]# scp /usr/lib/systemd/system/etcd.service k8s-node1:/usr/lib/systemd/system/
[root@k8s-master1 ~]# scp -r /opt/etcd/ k8s-node2:/opt/
[root@k8s-master1 ~]# scp /usr/lib/systemd/system/etcd.service k8s-node2:/usr/lib/systemd/system/


#在节点Node2和节点Node3分别修改etcd.conf配置文件
[root@k8s-node1 ~]# vim /opt/etcd/cfg/etcd.conf
#[Member]
ETCD_NAME="etcd-2"
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://192.168.1.21:2380"
ETCD_LISTEN_CLIENT_URLS="https://192.168.1.21:2379"

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.1.21:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.1.21:2379"
ETCD_INITIAL_CLUSTER="etcd-1=https://192.168.1.20:2380,etcd-2=https://192.168.1.21:2380,etcd-3=https://192.168.1.22:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"

[root@k8s-node2 ~]# vim /opt/etcd/cfg/etcd.conf
#[Member]
ETCD_NAME="etcd-3"
ETCD_DATA_DIR="/var/lib/etcd/default.etcd"
ETCD_LISTEN_PEER_URLS="https://192.168.1.22:2380"
ETCD_LISTEN_CLIENT_URLS="https://192.168.1.22:2379"

#[Clustering]
ETCD_INITIAL_ADVERTISE_PEER_URLS="https://192.168.1.22:2380"
ETCD_ADVERTISE_CLIENT_URLS="https://192.168.1.22:2379"
ETCD_INITIAL_CLUSTER="etcd-1=https://192.168.1.20:2380,etcd-2=https://192.168.1.21:2380,etcd-3=https://192.168.1.22:2380"
ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster"
ETCD_INITIAL_CLUSTER_STATE="new"


---------------master1、node1、node2节点------------------

#启动并设置开机启动
systemctl daemon-reload
systemctl enable etcd
systemctl start etcd

*注：master如果先启动了，会出现start悬停等待的现象，这时候可以先把node1、node2的etcd启动，随后master的etcd会正常启动。

#查看集群状态
[root@k8s-master1 ~]# ETCDCTL_API=3 /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.1.20:2379,https://192.168.1.21:2379,https://192.168.1.22:2379" endpoint health --write-out=table
+---------------------------+--------+-------------+-------+
|         ENDPOINT          | HEALTH |    TOOK     | ERROR |
+---------------------------+--------+-------------+-------+
| https://192.168.1.20:2379 |   true |  8.280002ms |       |
| https://192.168.1.21:2379 |   true |  8.113125ms |       |
| https://192.168.1.22:2379 |   true | 17.479134ms |       |
+---------------------------+--------+-------------+-------+

如果输出上面信息，就说明集群部署成功。
如果有问题第一步先看日志：/var/log/message 或 journalctl -u etcd

```

## 四 ，安装docker

### 1、下载并解压二进制包

```shell
以下在所有节点操作。这里采用二进制安装，用yum安装也一样
------------------------master1、node1、node2节点--------------------------

[root@k8s-node1 ~]# wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz
[root@k8s-node1 ~]# tar zxvf docker-19.03.9.tgz
[root@k8s-node1 ~]# mv docker/* /usr/bin
```

### 2、创建配置文件

```shell
------------------------master1、node1、node2节点--------------------------

[root@k8s-node1 ~]# mkdir /etc/docker
[root@k8s-node1 ~]# vim /etc/docker/daemon.json
{
  "registry-mirrors": ["https://b9pmyelo.mirror.aliyuncs.com"]
}
```

### 3、systemd管理docker

```shell
------------------------master1、node1、node2节点--------------------------

[root@k8s-node1 ~]# vim /usr/lib/systemd/system/docker.service
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target

[Service]
Type=notify
ExecStart=/usr/bin/dockerd
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TimeoutStartSec=0
Delegate=yes
KillMode=process
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s

[Install]
WantedBy=multi-user.target

#启动并设置开机启动
systemctl daemon-reload
systemctl enable docker
systemctl start docker

ps -aux |grep  docker|grep -v grep

```

## 五、部署Master

### 1、生成kube-apiserver证书

```shell
#创建目录
[root@k8s-master1 ~]# mkdir ca/k8s
[root@k8s-master1 ~]# cd ca/k8s

#自签证书颁发机构（CA）
[root@k8s-master k8s]# vim ca-config.json
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "kubernetes": {
         "expiry": "87600h",
         "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ]
      }
    }
  }
}
[root@k8s-master k8s]# vim ca-csr.json
{
    "CN": "kubernetes",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Beijing",
            "ST": "Beijing",
            "O": "k8s",
            "OU": "System"
        }
    ]
}

#生成证书
[root@k8s-master1 k8s]# cfssl gencert -initca ca-csr.json | cfssljson -bare ca -

会生成ca.pem和ca-key.pem文件
```



### 2、使用自签CA签发kube-apiserver HTTPS证书

```shell
#创建证书申请文件
[root@k8s-master1 k8s]# vim server-csr.json
{
    "CN": "kubernetes",
    "hosts": [
      "10.0.0.1",
      "127.0.0.1",
      "192.168.1.20",    #master1
      "192.168.1.21",    #node1
      "192.168.1.22",    #node2
      "192.168.1.23",    #master2（预留）
      "10.8.165.250",    #vip（预留）
      "kubernetes",
      "kubernetes.default",
      "kubernetes.default.svc",
      "kubernetes.default.svc.cluster",
      "kubernetes.default.svc.cluster.local"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "BeiJing",
            "ST": "BeiJing",
            "O": "k8s",
            "OU": "System"
        }
    ]
}

#生成证书
[root@k8s-master1 k8s]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server

会生成server.pem和server-key.pem文件
```

### 3、下载二进制文件

```shell
链接：https://pan.baidu.com/s/1oBCKAkxvzqlYPd9JxZ_QHQ?pwd=knyi 
提取码：knyi

#创建目录
[root@k8s-master1 k8s]# cd ~
[root@k8s-master1 ~]# mkdir -p /opt/kubernetes/{bin,cfg,ssl,logs}

#解压二进制包
[root@k8s-master1 ~]# tar -zxf kubernetes-v1.20.4-server-linux-amd64.tar.gz

#拷贝
[root@k8s-master1 ~]# cd kubernetes/server/bin
[root@k8s-master1 bin]# cp kube-apiserver kube-scheduler kube-controller-manager /opt/kubernetes/bin
[root@k8s-master1 bin]# cp kubectl /usr/bin/
```

### 4、部署kube-apiserver

```shell
#创建配置文件
[root@k8s-master1 bin]# vim /opt/kubernetes/cfg/kube-apiserver.conf
KUBE_APISERVER_OPTS="--logtostderr=false \
--v=2 \
--log-dir=/opt/kubernetes/logs \
--etcd-servers=https://192.168.1.20:2379,https://192.168.1.21:2379,https://192.168.1.22:2379 \
--bind-address=192.168.1.20 \
--secure-port=6443 \
--advertise-address=192.168.1.20 \
--allow-privileged=true \
--service-cluster-ip-range=10.0.0.0/24 \
--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \
--authorization-mode=RBAC,Node \
--enable-bootstrap-token-auth=true \
--token-auth-file=/opt/kubernetes/cfg/token.csv \
--service-node-port-range=30000-32767 \
--kubelet-client-certificate=/opt/kubernetes/ssl/server.pem \
--kubelet-client-key=/opt/kubernetes/ssl/server-key.pem \
--tls-cert-file=/opt/kubernetes/ssl/server.pem  \
--tls-private-key-file=/opt/kubernetes/ssl/server-key.pem \
--client-ca-file=/opt/kubernetes/ssl/ca.pem \
--service-account-key-file=/opt/kubernetes/ssl/ca-key.pem \
--service-account-issuer=api \
--service-account-signing-key-file=/opt/kubernetes/ssl/server-key.pem \
--etcd-cafile=/opt/etcd/ssl/ca.pem \
--etcd-certfile=/opt/etcd/ssl/server.pem \
--etcd-keyfile=/opt/etcd/ssl/server-key.pem \
--requestheader-client-ca-file=/opt/kubernetes/ssl/ca.pem \
--proxy-client-cert-file=/opt/kubernetes/ssl/server.pem \
--proxy-client-key-file=/opt/kubernetes/ssl/server-key.pem \
--requestheader-allowed-names=kubernetes \
--requestheader-extra-headers-prefix=X-Remote-Extra- \
--requestheader-group-headers=X-Remote-Group \
--requestheader-username-headers=X-Remote-User \
--enable-aggregator-routing=true \
--audit-log-maxage=30 \
--audit-log-maxbackup=3 \
--audit-log-maxsize=100 \
--audit-log-path=/opt/kubernetes/logs/k8s-audit.log"


参考说明
•	--logtostderr：启用日志
•	---v：日志等级
•	--log-dir：日志目录
•	--etcd-servers：etcd集群地址
•	--bind-address：监听地址
•	--secure-port：https安全端口
•	--advertise-address：集群通告地址
•	--allow-privileged：启用授权
•	--service-cluster-ip-range：Service虚拟IP地址段
•	--enable-admission-plugins：准入控制模块
•	--authorization-mode：认证授权，启用RBAC授权和节点自管理
•	--enable-bootstrap-token-auth：启用TLS bootstrap机制
•	--token-auth-file：bootstrap token文件
•	--service-node-port-range：Service nodeport类型默认分配端口范围
•	--kubelet-client-xxx：apiserver访问kubelet客户端证书
•	--tls-xxx-file：apiserver https证书
•	1.20版本必须加的参数：--service-account-issuer，--service-account-signing-key-file
•	--etcd-xxxfile：连接Etcd集群证书
•	--audit-log-xxx：审计日志
•	启动聚合层相关配置：--requestheader-client-ca-file，--proxy-client-cert-file，--proxy-client-key-file，--requestheader-allowed-names，--requestheader-extra-headers-prefix，--requestheader-group-headers，--requestheader-username-headers，--enable-aggregator-routing

#拷贝刚才生成的证书
[root@k8s-master1 bin]# cp ~/ca/k8s/ca*pem ~/ca/k8s/server*pem /opt/kubernetes/ssl/
```



  ```shell
  #配置token文件
  [root@k8s-master1 bin]# vim /opt/kubernetes/cfg/token.csv
  8e4908667d4d495dd8b9367aa1301317,kubelet-bootstrap,10001,"system:node-bootstrapper"
  
  *注：上述token可自行生成替换，但一定要与后续配置对应
  head -c 16 /dev/urandom | od -An -t x | tr -d ' '
  ```

**systemd管理apiserver**

```shell
[root@k8s-master1 bin]# vim /usr/lib/systemd/system/kube-apiserver.service
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf
ExecStart=/opt/kubernetes/bin/kube-apiserver $KUBE_APISERVER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target


#启动并设置开机启动
systemctl daemon-reload
systemctl enable kube-apiserver
systemctl start kube-apiserver
```

### 5、部署kube-controller-manager

```shell
#创建配置文件
[root@k8s-master1 bin]# vim /opt/kubernetes/cfg/kube-controller-manager.conf
KUBE_CONTROLLER_MANAGER_OPTS="--logtostderr=false \
--v=2 \
--log-dir=/opt/kubernetes/logs \
--leader-elect=true \
--kubeconfig=/opt/kubernetes/cfg/kube-controller-manager.kubeconfig \
--bind-address=127.0.0.1 \
--allocate-node-cidrs=true \
--cluster-cidr=10.244.0.0/16 \
--service-cluster-ip-range=10.0.0.0/24 \
--cluster-signing-cert-file=/opt/kubernetes/ssl/ca.pem \
--cluster-signing-key-file=/opt/kubernetes/ssl/ca-key.pem  \
--root-ca-file=/opt/kubernetes/ssl/ca.pem \
--service-account-private-key-file=/opt/kubernetes/ssl/ca-key.pem \
--experimental-cluster-signing-duration=87600h0m0s"   #证书过期时间10年






参数说明
•	--kubeconfig：连接apiserver配置文件
•	--leader-elect：当该组件启动多个时，自动选举（HA）
•	--cluster-signing-cert-file/--cluster-signing-key-file：自动为kubelet颁发证书的CA，与apiserver保持一致
```

生成kubeconfig文件

```shell
#生成kube-controller-manager证书
[root@k8s-master1 bin]# cd ~/ca/k8s/

[root@k8s-master1 k8s]# vim kube-controller-manager-csr.json
{
  "CN": "system:kube-controller-manager",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing",
      "ST": "BeiJing",
      "O": "system:masters",
      "OU": "System"
    }
  ]
}

[root@k8s-master1 k8s]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager

#生成kubeconfig文件
[root@k8s-master1 k8s]# KUBE_CONFIG="/opt/kubernetes/cfg/kube-controller-manager.kubeconfig"
[root@k8s-master1 k8s]# KUBE_APISERVER="https://192.168.1.20:6443"

·终端执行（4条）
kubectl config set-cluster kubernetes \
  --certificate-authority=/opt/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}

kubectl config set-credentials kube-controller-manager \
  --client-certificate=./kube-controller-manager.pem \
  --client-key=./kube-controller-manager-key.pem \
  --embed-certs=true \
  --kubeconfig=${KUBE_CONFIG}

kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-controller-manager \
  --kubeconfig=${KUBE_CONFIG}

kubectl config use-context default --kubeconfig=${KUBE_CONFIG}
```

systemd管理controller-manager

```shell
[root@k8s-master1 k8s]# vim /usr/lib/systemd/system/kube-controller-manager.service
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf
ExecStart=/usr/local/bin/kube-controller-manager $KUBE_CONTROLLER_MANAGER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target

#启动并设置开机启动
systemctl daemon-reload
systemctl enable kube-controller-manager
systemctl start kube-controller-manager
```

### 6、部署kube-scheduler

```shell
#创建配置文件
[root@k8s-master1 k8s]# vim /opt/kubernetes/cfg/kube-scheduler.conf
KUBE_SCHEDULER_OPTS="--logtostderr=false \
--v=2 \
--log-dir=/opt/kubernetes/logs \
--leader-elect \
--kubeconfig=/opt/kubernetes/cfg/kube-scheduler.kubeconfig \
--bind-address=127.0.0.1"

参数说明
•	--kubeconfig：连接apiserver配置文件
•	--leader-elect：当该组件启动多个时，自动选举（HA）
```

生成kubeconfig文件

```shell
#生成kube-scheduler证书（在/root/ca/k8s目录下）
[root@k8s-master1 k8s]# pwd
/root/ca/k8s

[root@k8s-master1 k8s]# vim kube-scheduler-csr.json
{
  "CN": "system:kube-scheduler",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing",
      "ST": "BeiJing",
      "O": "system:masters",
      "OU": "System"
    }
  ]
}


#生成证书
[root@k8s-master1 k8s]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler

[root@k8s-master1 k8s]# KUBE_CONFIG="/opt/kubernetes/cfg/kube-scheduler.kubeconfig"
[root@k8s-master1 k8s]# KUBE_APISERVER="https://192.168.1.20:6443"


·终端执行（4条）
kubectl config set-cluster kubernetes \
  --certificate-authority=/opt/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}

kubectl config set-credentials kube-scheduler \
  --client-certificate=./kube-scheduler.pem \
  --client-key=./kube-scheduler-key.pem \
  --embed-certs=true \
  --kubeconfig=${KUBE_CONFIG}

kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-scheduler \
  --kubeconfig=${KUBE_CONFIG}

kubectl config use-context default --kubeconfig=${KUBE_CONFIG}

```

systemd管理scheduler

```shell
[root@k8s-master1 k8s]# vim /usr/lib/systemd/system/kube-scheduler.service
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf
ExecStart=/opt/kubernetes/bin/kube-scheduler $KUBE_SCHEDULER_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target

#启动并设置开机启动
systemctl daemon-reload
systemctl enable kube-scheduler
systemctl start kube-scheduler
```

查看集群状态

```shell
#生成kubectl连接集群的证书
[root@k8s-master1 k8s]# vim admin-csr.json
{
  "CN": "admin",
  "hosts": [],
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "L": "BeiJing",
      "ST": "BeiJing",
      "O": "system:masters",
      "OU": "System"
    }
  ]
}

[root@k8s-master1 k8s]# cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin

#生成kubeconfig文件
[root@k8s-master1 k8s]# mkdir /root/.kube

[root@k8s-master1 k8s]# KUBE_CONFIG="/root/.kube/config"
[root@k8s-master1 k8s]# KUBE_APISERVER="https://192.168.1.20:6443"

·终端执行（4条）
kubectl config set-cluster kubernetes \
  --certificate-authority=/opt/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=${KUBE_CONFIG}

kubectl config set-credentials cluster-admin \
  --client-certificate=./admin.pem \
  --client-key=./admin-key.pem \
  --embed-certs=true \
  --kubeconfig=${KUBE_CONFIG}

kubectl config set-context default \
  --cluster=kubernetes \
  --user=cluster-admin \
  --kubeconfig=${KUBE_CONFIG}

kubectl config use-context default --kubeconfig=${KUBE_CONFIG}


#通过kubectl工具查看当前集群组件状态
root@k8s-master1 k8s]# kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE             ERROR
scheduler            Healthy   ok                  
controller-manager   Healthy   ok                  
etcd-2               Healthy   {"health":"true"}   
etcd-0               Healthy   {"health":"true"}   
etcd-1               Healthy   {"health":"true"} 





#若出现下列情况，可按下面操作
[root@k8s-master1 k8s]# kubectl get cs
NAME                 AGE
etcd-0               <unknown>
scheduler            <unknown>
controller-manager   <unknown>
etcd-2               <unknown>
etcd-1               <unknown>

#从1.16开始就显示为unknow 具体原因:https://segmentfault.com/a/1190000020912684


#临时解决办法（通过模板）
[root@k8s-master1 k8s]# kubectl get cs -o=go-template='{{printf "|NAME|STATUS|MESSAGE|\n"}}{{range .items}}{{$name := .metadata.name}}{{range .conditions}}{{printf "|%s|%s|%s|\n" $name .status .message}}{{end}}{{end}}'
|NAME|STATUS|MESSAGE|
|scheduler|True|ok|
|controller-manager|True|ok|
|etcd-1|True|{"health":"true"}|
|etcd-0|True|{"health":"true"}|
|etcd-2|True|{"health":"true"}|

#查看k8s的名称空间
[root@k8s-master1 k8s]# kubectl get ns
NAME              STATUS   AGE
default           Active   3h21m
kube-node-lease   Active   3h21m
kube-public       Active   3h21m
kube-system       Active   3h21m
```

## 六、部署Worker Node

### 1、创建工作目录并拷贝文件

```shell
--------------------node1、node2节点-------------------
[root@k8s-node1 ~]# mkdir -p /opt/kubernetes/{bin,cfg,ssl,logs}

#master将kubelet和kube-proxy拷贝给node1、node2节点
[root@k8s-master k8s]# cd ~/kubernetes/server/bin/
[root@k8s-master bin]# scp kubelet kube-proxy k8s-node1:/opt/kubernetes/bin/

#本地拷贝
[root@k8s-master1 bin]# cp kubelet kube-proxy /opt/kubernetes/bin

上传到/opt/kubernetes/bin下
```

### 2、部署kubelet

```shell
----------------------下面这些操作在master节点完成：---------------------------
将kubelet-bootstrap用户绑定到系统集群角色
[root@k8s-master1 ~]# /opt/kubernetes/bin/kubectl create clusterrolebinding kubelet-bootstrap \
  --clusterrole=system:node-bootstrapper \
  --user=kubelet-bootstrap
clusterrolebinding.rbac.authorization.k8s.io/kubelet-bootstrap created

创建kubeconfig文件:
在生成kubernetes证书的目录下执行以下命令生成kubeconfig文件：
[root@k8s-master1 ~]# cd /opt/crt/
指定apiserver 内网负载均衡地址
[root@k8s-master1 crt]# KUBE_APISERVER="https://192.168.246.162:6443"  #写你master的ip地址，集群中就写负载均衡的ip地址
[root@k8s-master1 crt]# BOOTSTRAP_TOKEN=674c457d4dcf2eefe4920d7dbb6b0ddc

# 设置集群参数
[root@k8s-master1 crt]# /opt/kubernetes/bin/kubectl config set-cluster kubernetes \
  --certificate-authority=ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=bootstrap.kubeconfig

# 设置客户端认证参数
[root@k8s-master crt]# /opt/kubernetes/bin/kubectl config set-credentials kubelet-bootstrap \
  --token=${BOOTSTRAP_TOKEN} \
  --kubeconfig=bootstrap.kubeconfig

# 设置上下文参数
[root@k8s-master crt]# /opt/kubernetes/bin/kubectl config set-context default \
  --cluster=kubernetes \
  --user=kubelet-bootstrap \
  --kubeconfig=bootstrap.kubeconfig

# 设置默认上下文
[root@k8s-master crt]# /opt/kubernetes/bin/kubectl config use-context default --kubeconfig=bootstrap.kubeconfig

#====================================================================================

# 创建kube-proxy kubeconfig文件

[root@k8s-master1 crt]# /opt/kubernetes/bin/kubectl config set-cluster kubernetes \
  --certificate-authority=ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=kube-proxy.kubeconfig

[root@k8s-master1 crt]# /opt/kubernetes/bin/kubectl config set-credentials kube-proxy \
  --client-certificate=kube-proxy.pem \
  --client-key=kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig

[root@k8s-master1 crt]# /opt/kubernetes/bin/kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig

[root@k8s-master1 crt]# /opt/kubernetes/bin/kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig


[root@k8s-master1 crt]# ls
bootstrap.kubeconfig  kube-proxy.kubeconfig

#必看：将这两个文件拷贝到Node节点/opt/kubernetes/cfg目录下。
[root@k8s-master1 crt]# scp *.kubeconfig k8s-node1:/opt/kubernetes/cfg/
[root@k8s-master1 crt]# scp *.kubeconfig k8s-node2:/opt/kubernetes/cfg/
```





```shell
----------------------下面这些操作在node节点完成：---------------------------
部署kubelet组件
#将前面下载的二进制包中的kubelet和kube-proxy拷贝到/opt/kubernetes/bin目录下。
将master上面的包拷贝过去
[root@k8s-master1 ~]# scp kubernetes-server-linux-amd64.tar.gz k8s-node1:/root/
[root@k8s-master1 ~]# scp kubernetes-server-linux-amd64.tar.gz k8s-node2:/root/
[root@k8s-node1 ~]# tar xzf kubernetes-server-linux-amd64.tar.gz
[root@k8s-node1 ~]# cd kubernetes/server/bin/
[root@k8s-node1 bin]# cp kubelet kube-proxy /opt/kubernetes/bin/
#=====================================================================================
在两个node节点创建kubelet配置文件：
[root@k8s-node1 ~]# vim /opt/kubernetes/cfg/kubelet
KUBELET_OPTS="--logtostderr=true \
--v=4 \
--hostname-override=192.168.246.164 \   #每个节点自己的ip地址
--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \
--bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \
--config=/opt/kubernetes/cfg/kubelet.config \
--cert-dir=/opt/kubernetes/ssl \
--pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0"  #这个镜像需要提前下载

[root@k8s-node1 ~]# docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0
[root@k8s-node2 ~]# docker pull registry.cn-hangzhou.aliyuncs.com/google-containers/pause-amd64:3.0
参数说明：
* --hostname-override 在集群中显示的主机名
* --kubeconfig 指定kubeconfig文件位置，会自动生成
* --bootstrap-kubeconfig 指定刚才生成的bootstrap.kubeconfig文件
* --cert-dir 颁发证书存放位置
* --pod-infra-container-image 管理Pod网络的镜像

其中/opt/kubernetes/cfg/kubelet.config配置文件如下：
[root@k8s-node1 ~]# vim /opt/kubernetes/cfg/kubelet.config
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
address: 192.168.246.164   #写你机器的ip地址
port: 10250
readOnlyPort: 10255
cgroupDriver: cgroupfs
clusterDNS: ["10.0.0.2"]      #不要改，就是这个ip地址
clusterDomain: cluster.local.
failSwapOn: false
authentication:
  anonymous:
    enabled: true
  webhook:
    enabled: false
    
systemd管理kubelet组件：
# vim /usr/lib/systemd/system/kubelet.service 
[Unit]
Description=Kubernetes Kubelet
After=docker.service
Requires=docker.service

[Service]
EnvironmentFile=/opt/kubernetes/cfg/kubelet
ExecStart=/opt/kubernetes/bin/kubelet $KUBELET_OPTS
Restart=on-failure
KillMode=process

[Install]
WantedBy=multi-user.target

启动：
# systemctl daemon-reload
# systemctl enable kubelet
# systemctl start kubelet
[root@k8s-master ~]# /opt/kubernetes/bin/kubectl get csr
NAME                                                   AGE       REQUESTOR           CONDITION
node-csr-F5AQ8SeoyloVrjPuzSbzJnFKQaUsier7EGvNFXLKTqM   17s       kubelet-bootstrap   Pending
node-csr-bjeHSWXOuUDSHganJPL_hDz_8jjYhM2FQyTkbA9pM0Q   18s       kubelet-bootstrap   Pending

在Master审批Node加入集群：
启动后还没加入到集群中，需要手动允许该节点才可以。在Master节点查看请求签名的Node：
[root@k8s-master1 ~]# /opt/kubernetes/bin/kubectl certificate approve XXXXID
注意：xxxid 指的是上面的NAME这一列
[root@k8s-master1 ~]# /opt/kubernetes/bin/kubectl get csr
NAME                                                   AGE       REQUESTOR           CONDITION
node-csr--1TVDzcozo7NoOD3WS2t9xLQqNunsVXj_i2AQ5x1mbs   1m        kubelet-bootstrap   Approved,Issued
node-csr-L0wqvr69oy8rzXwFm1u1uNx4aEMOOvd_RWPxaAERn_w   27m       kubelet-bootstrap   Approved,Issued


查看集群节点信息：
[root@k8s-master1 ~]# /opt/kubernetes/bin/kubectl get node
NAME              STATUS    ROLES     AGE       VERSION
192.168.246.164   Ready     <none>    1m        v1.11.10
192.168.246.165   Ready     <none>    17s       v1.11.10
```

### 3.部署kube-proxy组件

```shell
创建kube-proxy配置文件：还是在所有node节点
[root@k8s-node1 ~]# vim /opt/kubernetes/cfg/kube-proxy
# cat /opt/kubernetes/cfg/kube-proxy
KUBE_PROXY_OPTS="--logtostderr=true \
--v=4 \
--hostname-override=192.168.246.164 \   #写每个node节点ip
--cluster-cidr=10.0.0.0/24 \           //不要改，就是这个ip
--kubeconfig=/opt/kubernetes/cfg/kube-proxy.kubeconfig"

systemd管理kube-proxy组件：
[root@k8s-node1 ~]# cd /usr/lib/systemd/system
# cat /usr/lib/systemd/system/kube-proxy.service 
[Unit]
Description=Kubernetes Proxy
After=network.target

[Service]
EnvironmentFile=-/opt/kubernetes/cfg/kube-proxy
ExecStart=/opt/kubernetes/bin/kube-proxy $KUBE_PROXY_OPTS
Restart=on-failure

[Install]
WantedBy=multi-user.target

启动：

# systemctl daemon-reload
# systemctl enable kube-proxy
# systemctl start kube-proxy

在master查看集群状态
[root@k8s-master1 ~]# /opt/kubernetes/bin/kubectl get node
NAME              STATUS    ROLES     AGE       VERSION
192.168.246.164   Ready     <none>    19m       v1.11.10
192.168.246.165   Ready     <none>    18m       v1.11.10

查看集群状态
[root@k8s-master1 ~]# /opt/kubernetes/bin/kubectl get cs
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok                   
controller-manager   Healthy   ok                   
etcd-0               Healthy   {"health": "true"}   
etcd-1               Healthy   {"health": "true"}   
etcd-2               Healthy   {"health": "true"}
=====================================================================================
```

### 4、部署网络组件（Calico、flanneld二选一）

Calico

```shell
Calico是一个纯三层的数据中心网络方案，是目前Kubernetes主流的网络方案

#上传yaml文件
链接：https://pan.baidu.com/s/1jPzSdsnFKSFxkVQzc2lQ9g?pwd=x311 
提取码：x311



#部署Calico
[root@k8s-master1 k8s]# cd /opt/kubernetes/cfg/

*上传至/opt/kubernetes/cfg/

[root@k8s-master1 cfg]# kubectl apply -f calico.yaml
[root@k8s-master1 cfg]# kubectl get pods -n kube-system


等Calico Pod都Running，节点也会准备就绪
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
可能有点久，要初始化创建对应镜像，好几分钟，等吧骚年
waiting......................
！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

[root@k8s-master1 cfg]# kubectl get pods -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
calico-kube-controllers-97769f7c7-9d49d   1/1     Running   0          9m16s
calico-node-8djzj                         1/1     Running   0          9m16s

*看网速、看脸    快10分钟了

[root@k8s-master1 cfg]# kubectl get node
NAME          STATUS   ROLES    AGE   VERSION
k8s-master1   Ready    <none>   23m   v1.20.4
```

flanneld

```shell
--------------------------master1节点-----------------------
/opt/etcd/bin/etcdctl \
--cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem \
--endpoints="https://192.168.1.20:2379,https://192.168.1.21:2379,https://192.168.1.22:2379" \
put /coreos.com/network/config  '{ "Network": "172.17.0.0/16", "Backend": {"Type": "vxlan"}}'

-------------------master1、node1、node2节点------------------------
#下载二进制包
链接：https://pan.baidu.com/s/1vSxuXNQZU8yXkcCvDED1Pw?pwd=0ind 
提取码：0ind

[root@k8s-node1 ~]# tar zvxf flannel-v0.13.0-linux-amd64.tar.gz
[root@k8s-node1 ~]# mv flanneld mk-docker-opts.sh /opt/kubernetes/bin


#配置Flannel
[root@k8s-node1 ~]# vim /opt/kubernetes/cfg/flanneld
FLANNEL_OPTIONS="--etcd-endpoints=https://192.168.1.20:2379,https://192.168.1.21:2379,https://192.168.1.22:2379 -etcd-cafile=/opt/etcd/ssl/ca.pem -etcd-certfile=/opt/etcd/ssl/server.pem -etcd-keyfile=/opt/etcd/ssl/server-key.pem"


#systemd管理Flannel
[root@k8s-node1 ~]# vim /usr/lib/systemd/system/flanneld.service
[Unit]
Description=Flanneld overlay address etcd agent
After=network-online.target network.target
Before=docker.service

[Service]
Type=notify
EnvironmentFile=/opt/kubernetes/cfg/flanneld
ExecStart=/opt/kubernetes/bin/flanneld --ip-masq $FLANNEL_OPTIONS
ExecStartPost=/opt/kubernetes/bin/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/subnet.env
Restart=on-failure

[Install]
WantedBy=multi-user.target

#启动flannel和docker
systemctl daemon-reload
systemctl start flanneld
systemctl enable flanneld
systemctl daemon-reload
systemctl restart docker
```

**报错（Couldn‘t fetch network config）**

```shell
原因：flanneld目前不能与etcdV3直接交互
参考：https://blog.51cto.com/u_8355320/2564588

#开启etcd 支持V2api功能，在etcd启动参数中加入 --enable-v2参数，并重启etcd2

master、node1、node2都改，并重启
[root@k8s-master etcd]# vim /usr/lib/systemd/system/etcd.service
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
EnvironmentFile=/opt/etcd/cfg/etcd.conf
ExecStart=/opt/etcd/bin/etcd \
--cert-file=/opt/etcd/ssl/server.pem \
--key-file=/opt/etcd/ssl/server-key.pem \
--peer-cert-file=/opt/etcd/ssl/server.pem \
--peer-key-file=/opt/etcd/ssl/server-key.pem \
--trusted-ca-file=/opt/etcd/ssl/ca.pem \
--peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \
--logger=zap \
--enable-v2     #此处添加
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

[root@master1 ~]# systemctl daemon-reload
[root@master1 ~]# systemctl restart etcd

·master查看etcd集群健康状况
[root@k8s-master etcd]# ETCDCTL_API=2 /opt/etcd/bin/etcdctl --ca-file=/opt/etcd/ssl/ca.pem --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.1.20:2379,https://192.168.1.21:2379,https://192.168.1.22:2379" cluster-health

#删除原来写入的子网信息
[root@k8s-master etcd]# /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints="https://192.168.1.20:2379,https://192.168.1.21:2379,https://192.168.1.22:2379" del /coreos.com/network/config

#重新使用V2写入子网信息
ETCDCTL_API=2 /opt/etcd/bin/etcdctl \
--ca-file=/opt/etcd/ssl/ca.pem --cert-file=/opt/etcd/ssl/server.pem --key-file=/opt/etcd/ssl/server-key.pem \
--endpoints="https://192.168.1.20:2379,https://192.168.1.21:2379,https://192.168.1.22:2379" \
set /coreos.com/network/config '{ "Network": "172.17.0.0/16", "Backend": {"Type": "vxlan"}}'

#重启flanneld服务
systemctl daemon-reload
systemctl start flanneld
systemctl enable flanneld

#修改docker文件
[root@k8s-node1 ~]# vim /usr/lib/systemd/system/docker.service
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target

[Service]
Type=notify
EnvironmentFile=/run/flannel/subnet.env
ExecStart=/usr/bin/dockerd $DOCKER_NETWORK_OPTIONS
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TimeoutStartSec=0
Delegate=yes
KillMode=process
Restart=on-failure
StartLimitBurst=3
StartLimitInterval=60s

[Install]
WantedBy=multi-user.target

#重启docker
systemctl daemon-reload
systemctl restart docker
```

### 5、授权apiserver访问kubelet

```shell
#应用场景：例如kubectl logs

[root@k8s-master1 cfg]# vim apiserver-to-kubelet-rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:kube-apiserver-to-kubelet
rules:
  - apiGroups:
      - ""
    resources:
      - nodes/proxy
      - nodes/stats
      - nodes/log
      - nodes/spec
      - nodes/metrics
      - pods/log
    verbs:
      - "*"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: system:kube-apiserver
  namespace: ""
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:kube-apiserver-to-kubelet
subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: User
    name: kubernetes


[root@k8s-master1 cfg]# kubectl apply -f apiserver-to-kubelet-rbac.yaml
```

### 6、新增加Worker Node(如果需要)

```shell
----------------------master1节点-------------------------

#在Master1节点将Worker Node涉及文件拷贝到node1
[root@k8s-master1 cfg]# scp -r /opt/kubernetes k8s-node1:/opt/
[root@k8s-master1 cfg]# scp -r /usr/lib/systemd/system/{kubelet,kube-proxy}.service k8s-node1:/usr/lib/systemd/system
[root@k8s-master1 cfg]# scp /opt/kubernetes/ssl/ca.pem k8s-node1:/opt/kubernetes/ssl/

------------------------node1节点------------------------
#删除kubelet证书和kubeconfig文件
[root@k8s-node1 ~]# rm -f /opt/kubernetes/cfg/kubelet.kubeconfig
[root@k8s-node1 ~]# rm -f /opt/kubernetes/ssl/kubelet*

*注：这几个文件是证书申请审批后自动生成的，每个Node不同，必须删除


#修改对应文件的主机名
[root@k8s-node1 ~]# vim /opt/kubernetes/cfg/kubelet.conf
--hostname-override=k8s-node1
[root@k8s-node1 ~]# vim /opt/kubernetes/cfg/kube-proxy-config.yml
hostnameOverride: k8s-node1

#启动并设置开机启动
systemctl daemon-reload
systemctl enable kubelet kube-proxy
systemctl start kubelet kube-proxy

---------------------------master1节点--------------------
#在Master1上批准新Node kubelet证书申请

*查看证书请求
[root@k8s-master1 cfg]# kubectl get csr
NAME                                                   AGE   SIGNERNAME                                    REQUESTOR           CONDITION
node-csr-0UTuuhUTPbL02uDpLinrwBc_YDnmXj3t-JjUqMM247I   41m   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Approved,Issued
node-csr-xQsFeNF5nlB-rZQr2cIxFB18ET3kAGYHSC9GMSKDoI8   41s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending

*授权请求（Pending，一定要是待定状态的）
[root@k8s-master1 cfg]# kubectl certificate approve node-csr-xQsFeNF5nlB-rZQr2cIxFB18ET3kAGYHSC9GMSKDoI8
certificatesigningrequest.certificates.k8s.io/node-csr-xQsFeNF5nlB-rZQr2cIxFB18ET3kAGYHSC9GMSKDoI8 approved

#查看Node状态
[root@k8s-master1 cfg]# kubectl get node
NAME          STATUS     ROLES    AGE   VERSION
k8s-master1   Ready      <none>   41m   v1.20.4
k8s-node1     NotReady   <none>   61s   v1.20.4


*发现新加入的k8s-node1节点是NotReady状态，不要急，等待一下，跟master节点一样，Calico在做初始化

*这个时候可以去做node2，跟加入node1的步骤一样，当然最后也要等！！！
```

**最终加入结果**

```shell
#查看名称空间kube-system中的pod情况
[root@k8s-master1 cfg]# kubectl get pods -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
calico-kube-controllers-97769f7c7-9d49d   1/1     Running   0          42m
calico-node-8djzj                         1/1     Running   0          42m
calico-node-h6ghf                         1/1     Running   0          15m
calico-node-nj9l7                         1/1     Running   0          8m1s


#查看Node状态
[root@k8s-master1 cfg]# kubectl get node
NAME          STATUS   ROLES    AGE     VERSION
k8s-master1   Ready    <none>   56m     v1.20.4
k8s-node1     Ready    <none>   16m     v1.20.4
k8s-node2     Ready    <none>   8m25s   v1.20.4
```

## 七、部署Dashboard和CoreDNS

### 1、部署Dashboard

```shell
----------------------master1节点-------------------------
*上面安装Calico时已经下载好了

[root@k8s-master1 cfg]# kubectl apply -f kubernetes-dashboard.yaml

# 查看部署
[root@k8s-master1 cfg]# kubectl get pods,svc -n kubernetes-dashboard
NAME                                             READY   STATUS              RESTARTS   AGE
pod/dashboard-metrics-scraper-7b59f7d4df-s7c6g   0/1     ContainerCreating   0          27s
pod/kubernetes-dashboard-74d688b6bc-5ln4n        0/1     ContainerCreating   0          27s

NAME                                TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
service/dashboard-metrics-scraper   ClusterIP   10.0.0.19    <none>        8000/TCP        27s
service/kubernetes-dashboard        NodePort    10.0.0.9     <none>        443:30001/TCP   27s

*发现状态是ContainerCreating，即容器创建中，等待吧.......
*全部起来大概3分钟左右



#创建service account并绑定默认cluster-admin管理员集群角色
[root@k8s-master1 cfg]# kubectl create serviceaccount dashboard-admin -n kube-system
[root@k8s-master1 cfg]# kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin
[root@k8s-master1 cfg]# kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/{print $1}')
Name:         dashboard-admin-token-hclxd
Namespace:    kube-system
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: dashboard-admin
              kubernetes.io/service-account.uid: 03acc120-0133-4ccd-8047-9830cff868b3

Type:  kubernetes.io/service-account-token

Data
====
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6InV5ejZ2MlowdnNJaXVTQTJRUW0wTU50Nk01SEdoYVF1N3diMG9oYTRoUkEifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJkYXNoYm9hcmQtYWRtaW4tdG9rZW4taGNseGQiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGFzaGJvYXJkLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiMDNhY2MxMjAtMDEzMy00Y2NkLTgwNDctOTgzMGNmZjg2OGIzIiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmRhc2hib2FyZC1hZG1pbiJ9.ON_4fihI9XykB46854v4Lge1AMrKpKvTrhc5Mc1SguroxalskH_hUAtDTBinODOzcz2TP3aJz6uQ5Rq3UWND8i9AcuJl9f9Kpcaml3XnR6sdJSkwNGPvqLxK-uY1pbo-NlOaMs4LjgSJ5_dzLRt4KoLXDF96MSTAenY8E_K_pwfADF67qPUB90rGbyh-jedj9u_F0X4mQf7URYqEDDU1VFMYoVvuD0XdKwdlzRP-_juEXRmdhJoenigr-Y_KwZomWAkIadwK_lKKsSADCXD6uzcTTHZCNnKJFUaClw-oDL214O5CF79Y48nl4ZNqYqUd09X9Rr3qz3PPCrKcY9qHyg
ca.crt:     1359 bytes
namespace:  11 bytes


#访问地址：https://NodeIP:30001

*注意一定要加https://    不然默认就是http，会错哦
*随后用上述生成的token访问
```

### 2、部署CoreDNS

```shell
----------------------master1节点-------------------------
*上面安装Calico时已经下载好了

#CoreDNS用于集群内部Service名称解析
[root@k8s-master1 cfg]# kubectl apply -f coredns.yaml
[root@k8s-master1 cfg]# kubectl get pods -n kube-system


[root@k8s-master1 cfg]# kubectl get pods -n kube-system
NAME                                      READY   STATUS              RESTARTS   AGE
calico-kube-controllers-97769f7c7-9d49d   1/1     Running             0          60m
calico-node-8djzj                         1/1     Running             0          60m
calico-node-h6ghf                         1/1     Running             0          33m
calico-node-nj9l7                         1/1     Running             0          25m
coredns-6d8f96d957-kzn2g                  0/1     ContainerCreating   0          23s

*接着等，嘎嘎.............（这个快几秒？）

#DNS解析测试
[root@k8s-master1 cfg]# kubectl run -it --rm dns-test --image=busybox:1.28.4 sh
If you don't see a command prompt, try pressing enter.
/ # nslookup kubernetes
Server:    10.0.0.2
Address 1: 10.0.0.2 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes
Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local



解析没问题。
至此一个单Master集群就搭建完成了！这个环境就足以满足实验了，如果你的服务器配置较高，可继续扩容多Master集群！
```

## 八、扩容多Master（高可用架构）

### 1、部署Master2 Node

```shell
Master2 与已部署的Master1所有操作一致。所以我们只需将Master1所有K8s文件拷贝过来，再修改下服务器IP和主机名启动即可。



#安装Docker
-----------------------master1节点-----------------------
[root@k8s-master1 cfg]# scp /usr/bin/docker* 192.168.1.23:/usr/bin
[root@k8s-master1 cfg]# scp /usr/bin/runc 192.168.1.23:/usr/bin
[root@k8s-master1 cfg]# scp /usr/bin/containerd* 192.168.1.23:/usr/bin
[root@k8s-master1 cfg]# scp /usr/lib/systemd/system/docker.service 192.168.1.23:/usr/lib/systemd/system
[root@k8s-master1 cfg]# scp -r /etc/docker 192.168.1.23:/etc

# 在Master2启动Docker
-----------------------master2节点-----------------------
systemctl daemon-reload
systemctl enable docker
systemctl start docker


#在Master2创建etcd证书目录
-----------------------master2节点-----------------------
[root@k8s-master2 ~]# mkdir -p /opt/etcd/ssl


#拷贝Master1上所有K8s文件和etcd证书到Master2
-----------------------master1节点-----------------------
[root@k8s-master1 cfg]# scp -r /opt/kubernetes 192.168.1.23:/opt
[root@k8s-master1 cfg]# scp -r /opt/etcd/ssl 192.168.1.23:/opt/etcd
[root@k8s-master1 cfg]# scp /usr/lib/systemd/system/kube* 192.168.1.23:/usr/lib/systemd/system
[root@k8s-master1 cfg]# scp /usr/bin/kubectl  192.168.1.23:/usr/bin
[root@k8s-master1 cfg]# scp -r ~/.kube 192.168.1.23:~


#删除kubelet证书和kubeconfig文件
-----------------------master2节点-----------------------
[root@k8s-master2 ~]# rm -f /opt/kubernetes/cfg/kubelet.kubeconfig
[root@k8s-master2 ~]# rm -f /opt/kubernetes/ssl/kubelet*


#修改配置文件IP和主机名
-----------------------master2节点-----------------------

*修改apiserver、kubelet和kube-proxy配置文件为本地IP
[root@k8s-master2 ~]# vim /opt/kubernetes/cfg/kube-apiserver.conf
--bind-address=192.168.1.23
--advertise-address=192.168.1.23

[root@k8s-master2 ~]# vim /opt/kubernetes/cfg/kube-controller-manager.kubeconfig
server: https://192.168.1.23:6443

[root@k8s-master2 ~]# vim /opt/kubernetes/cfg/kube-scheduler.kubeconfig
server: https://192.168.1.23:6443

[root@k8s-master2 ~]# vim /opt/kubernetes/cfg/bootstrap.kubeconfig
server: https://192.168.1.23:6443

[root@k8s-master2 ~]# vim /opt/kubernetes/cfg/kube-proxy.kubeconfig
server: https://192.168.1.23:6443

[root@k8s-master2 ~]# vim /opt/kubernetes/cfg/kubelet.conf
--hostname-override=k8s-master2

[root@k8s-master2 ~]# vim /opt/kubernetes/cfg/kube-proxy-config.yml
hostnameOverride: k8s-master2

[root@k8s-master2 ~]# vi ~/.kube/config
server: https://192.168.1.23:6443


#启动设置开机启动
-----------------------master2节点-----------------------
systemctl daemon-reload
systemctl enable kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy
systemctl start kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy
```

**检验并加入集群**

```shell
---------------------可master1  也可master2----------------
因为两者都是master嘛


#查看集群状态
[root@k8s-master2 ~]# kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE             ERROR
controller-manager   Healthy   ok                  
scheduler            Healthy   ok                  
etcd-1               Healthy   {"health":"true"}   
etcd-0               Healthy   {"health":"true"}   
etcd-2               Healthy   {"health":"true"}


#批准kubelet证书申请

*查看证书请求
[root@k8s-master2 ~]# kubectl get csr
NAME                                                   AGE     SIGNERNAME                                    REQUESTOR           CONDITION
node-csr--okVOhcnMlwp9j2L64uYd6HKiopCDU1FQf9Ywj_EUhw   2m55s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending
node-csr-BQJv1fS07fW1u4uPTID4M0ybNJV60Br71DjA67DmJxk   64m     kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Approved,Issued
node-csr-xQsFeNF5nlB-rZQr2cIxFB18ET3kAGYHSC9GMSKDoI8   73m     kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Approved,Issued

*授权请求
[root@k8s-master2 ~]# kubectl certificate approve node-csr--okVOhcnMlwp9j2L64uYd6HKiopCDU1FQf9Ywj_EUhw
certificatesigningrequest.certificates.k8s.io/node-csr--okVOhcnMlwp9j2L64uYd6HKiopCDU1FQf9Ywj_EUhw approved


# 查看Node
[root@k8s-master2 ~]# kubectl get node
NAME          STATUS     ROLES    AGE    VERSION
k8s-master1   Ready      <none>   113m   v1.20.4
k8s-master2   NotReady   <none>   54s    v1.20.4
k8s-node1     Ready      <none>   73m    v1.20.4
k8s-node2     Ready      <none>   65m    v1.20.4


[root@k8s-master1 cfg]# kubectl get node
NAME          STATUS     ROLES    AGE    VERSION
k8s-master1   Ready      <none>   113m   v1.20.4
k8s-master2   NotReady   <none>   42s    v1.20.4
k8s-node1     Ready      <none>   73m    v1.20.4
k8s-node2     Ready      <none>   65m    v1.20.4


*NotReady是因为Calico正在为master2进行初始化相关网络镜像

Waiting......................
```

**最终结果**

```shell
[root@k8s-master2 ~]# kubectl get pod -n kube-system
NAME                                      READY   STATUS    RESTARTS   AGE
calico-kube-controllers-97769f7c7-9d49d   1/1     Running   0          107m
calico-node-8djzj                         1/1     Running   0          107m
calico-node-bkdm6                         1/1     Running   0          8m2s
calico-node-h6ghf                         1/1     Running   0          80m
calico-node-nj9l7                         1/1     Running   0          72m
coredns-6d8f96d957-kzn2g                  1/1     Running   0          47m



[root@k8s-master2 ~]# kubectl get node
NAME          STATUS   ROLES    AGE    VERSION
k8s-master1   Ready    <none>   120m   v1.20.4
k8s-master2   Ready    <none>   8m6s   v1.20.4
k8s-node1     Ready    <none>   80m    v1.20.4
k8s-node2     Ready    <none>   72m    v1.20.4
```

### 2、部署Nginx+Keepalived高可用负载均衡器

**安装软件包**

```shell
----------------------master1、master2节点-----------------
#安装软件包（主/备）
[root@k8s-master1 cfg]# yum -y install epel-release nginx keepalived
```

**Nginx**

```shell
----------------------master1、master2节点-----------------
#Nginx配置文件（主/备一样）
[root@k8s-master1 cfg]# vim /etc/nginx/nginx.conf
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

# 四层负载均衡，为两台Master apiserver组件提供负载均衡
stream {

    log_format  main  '$remote_addr $upstream_addr - [$time_local] $status $upstream_bytes_sent';

    access_log  /var/log/nginx/k8s-access.log  main;

    upstream k8s-apiserver {
       server 192.168.1.20:6443;   # Master1 APISERVER IP:PORT
       server 192.168.1.23:6443;   # Master2 APISERVER IP:PORT
    }

    server {
       listen 16443; # 由于nginx与master节点复用，这个监听端口不能是6443，否则会冲突
       proxy_pass k8s-apiserver;
    }
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    server {
        listen       80 default_server;
        server_name  _;

        location / {
        }
    }
}
```

Keepalived

```shell
------------------------master1节点---------------------
#keepalived配置文件（Nginx Master）
[root@k8s-master1 cfg]# vim /etc/keepalived/keepalived.conf
global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 127.0.0.1
   smtp_connect_timeout 30
   router_id NGINX_MASTER
}

vrrp_script check_nginx {
    script "/etc/keepalived/check_nginx.sh"
}

vrrp_instance VI_1 {
    state MASTER
    interface ens33  # 修改为实际网卡名
    virtual_router_id 51 # VRRP 路由 ID实例，每个实例是唯一的
    priority 100    # 优先级，备服务器设置 90
    advert_int 1    # 指定VRRP 心跳包通告间隔时间，默认1秒
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    # 虚拟IP
    virtual_ipaddress {
        10.8.165.250/24
    }
    track_script {
        check_nginx
    }
}


说明：
•	vrrp_script：指定检查nginx工作状态脚本（根据nginx状态判断是否故障转移）
•	virtual_ipaddress：虚拟IP（VIP）


#准备上述配置文件中检查nginx运行状态的脚本
[root@k8s-master1 cfg]# vim /etc/keepalived/check_nginx.sh
#!/bin/bash
count=$(ss -antp |grep nginx |egrep -cv "grep|$$")

if [ "$count" -eq 0 ];then
    exit 1
else
    exit 0
fi


#赋予脚本权限
[root@k8s-master1 cfg]# chmod +x /etc/keepalived/check_nginx.sh


------------------------master2节点---------------------
#keepalived配置文件（Nginx Backup）
[root@k8s-master2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
   notification_email {
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 127.0.0.1
   smtp_connect_timeout 30
   router_id NGINX_BACKUP
}

vrrp_script check_nginx {
    script "/etc/keepalived/check_nginx.sh"
}

vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    virtual_router_id 51 # VRRP 路由 ID实例，每个实例是唯一的
    priority 90
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        10.8.165.250/24
    }
    track_script {
        check_nginx
    }
}


#准备上述配置文件中检查nginx运行状态的脚本
[root@k8s-master2 ~]# vim /etc/keepalived/check_nginx.sh
#!/bin/bash
count=$(ss -antp |grep nginx |egrep -cv "grep|$$")

if [ "$count" -eq 0 ];then
    exit 1
else
    exit 0
fi

#赋予脚本权限
[root@k8s-master2 ~]# chmod +x /etc/keepalived/check_nginx.sh

*注：keepalived根据脚本返回状态码（0为工作正常，非0不正常）判断是否故障转移。
```

**开启nginx、keepalived**

```shell
-------------------master1、master2节点--------------------
#启动并设置开机启动
systemctl daemon-reload
systemctl enable nginx keepalived
systemctl start nginx keepalived

*报错
[root@k8s-master1 cfg]# journalctl -xe -u nginx
...
-- Unit nginx.service has begun starting up.
6月 09 21:47:41 k8s-master1 nginx[30694]: nginx: [emerg] unknown directive "stream" in /etc/nginx/nginx.conf:13
...

*解决
**应该是缺少modules模块
[root@k8s-master1 cfg]# yum -y install nginx-all-modules.noarch
[root@k8s-master1 cfg]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful


最后重启nginx服务



#查看keepalived工作状态
[root@k8s-master1 cfg]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:79:95:e6 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.20/24 brd 10.8.165.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet 10.8.165.250/24 scope global secondary ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::e187:8e2f:2977:6d12/64 scope link 
       valid_lft forever preferred_lft forever
    inet6 fe80::82cf:7f96:a8f:69e1/64 scope link tentative dadfailed 
       valid_lft forever preferred_lft forever


[root@k8s-master2 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:ab:04:62 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.23/24 brd 10.8.165.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:feab:462/64 scope link 
       valid_lft forever preferred_lft forever

在Nginx Master上可以看到，在ens33网卡绑定了10.8.165.250 虚拟IP，说明工作正常
```

**关闭主节点Nginx，测试VIP是否漂移到备节点服务器**

```shell
#关闭主节点Nginx，测试VIP是否漂移到备节点服务器
------------------------master1节点---------------------
[root@k8s-master1 cfg]# pkill nginx
[root@k8s-master1 cfg]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:79:95:e6 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.20/24 brd 10.8.165.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::e187:8e2f:2977:6d12/64 scope link 
       valid_lft forever preferred_lft forever
    inet6 fe80::82cf:7f96:a8f:69e1/64 scope link tentative dadfailed 
       valid_lft forever preferred_lft forever


[root@k8s-master2 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:ab:04:62 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.23/24 brd 10.8.165.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet 10.8.165.250/24 scope global secondary ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:feab:462/64 scope link 
       valid_lft forever preferred_lft forever


在Nginx Backup可以看到，在ens33网卡绑定了10.8.165.250 虚拟IP，漂移成功。


[root@k8s-master1 cfg]# systemctl start nginx
[root@k8s-master1 cfg]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:79:95:e6 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.20/24 brd 10.8.165.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet 10.8.165.250/24 scope global secondary ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::e187:8e2f:2977:6d12/64 scope link 
       valid_lft forever preferred_lft forever
    inet6 fe80::82cf:7f96:a8f:69e1/64 scope link tentative dadfailed 
       valid_lft forever preferred_lft forever

[root@k8s-master2 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:ab:04:62 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.23/24 brd 10.8.165.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:feab:462/64 scope link 
       valid_lft forever preferred_lft forever


当Nginx Master重新启动nginx服务后，VIP又从新漂移绑定到ens33上，而Nginx Backup的ens33网卡上的VIP解绑。
```

**访问负载均衡器测试**

```shell
#找K8s集群中任意一个节点，使用curl查看K8s版本测试，使用VIP访问

------------------------node1节点--------------------------
[root@k8s-master1 cfg]# curl -k https://10.8.165.250:16443/version
curl: (35) TCP connection reset by peer


[root@k8s-master1 cfg]# tail /var/log/nginx/k8s-access.log -f
192.168.1.21 192.168.31.71:6443, 192.168.31.74:6443 - [09/Jun/2022:22:12:56 +0800] 502 0, 0
192.168.1.21 k8s-apiserver - [09/Jun/2022:22:15:02 +0800] 502 0
192.168.1.20 192.168.31.74:6443, 192.168.31.71:6443 - [09/Jun/2022:22:16:02 +0800] 502 0, 0
192.168.1.21 192.168.31.74:6443, k8s-apiserver - [09/Jun/2022:22:17:56 +0800] 502 0, 0
192.168.1.21 k8s-apiserver - [09/Jun/2022:22:18:00 +0800] 502 0
192.168.1.21 192.168.31.71:6443, 192.168.31.74:6443 - [09/Jun/2022:22:18:51 +0800] 502 0, 0
192.168.1.21 192.168.31.71:6443, 192.168.31.74:6443 - [09/Jun/2022:22:20:03 +0800] 502 0, 0
192.168.1.21 192.168.31.71:6443, 192.168.31.74:6443 - [09/Jun/2022:22:22:21 +0800] 502 0, 0
192.168.1.21 192.168.31.71:6443, 192.168.31.74:6443 - [09/Jun/2022:22:26:21 +0800] 502 0, 0
192.168.1.21 192.168.31.71:6443, 192.168.31.74:6443 - [09/Jun/2022:22:28:38 +0800] 502 0, 0
192.168.1.21 192.168.31.71:6443, 192.168.31.74:6443 - [09/Jun/2022:22:41:47 +0800] 502 0, 0

到此还没结束，还有下面最关键的一步
```

### 3、修改所有Worker Node连接LB VIP

```shell
#在所有Worker Node执行
------------------master1、node1、node2节点----------------
[root@k8s-master1 cfg]# sed -i 's#192.168.1.20:6443#10.8.165.250:16443#' /opt/kubernetes/cfg/*

------------------------master2节点-----------------------
[root@k8s-master2 ~]# sed -i 's#192.168.1.23:6443#10.8.165.250:16443#' /opt/kubernetes/cfg/*


--------------master1、master2、node1、node2节点----------
systemctl restart kubelet kube-proxy


[root@k8s-master1 cfg]# kubectl get node
NAME          STATUS     ROLES    AGE     VERSION
k8s-master1   NotReady   <none>   3h28m   v1.20.4
k8s-master2   Ready      <none>   95m     v1.20.4
k8s-node1     NotReady   <none>   168m    v1.20.4
k8s-node2     NotReady   <none>   160m    v1.20.4
```

# 九、高可用测试

## 1、宕机master2

```shell
模拟宕机master2


[root@k8s-master1 ~]# kubectl get node
NAME          STATUS     ROLES    AGE     VERSION
k8s-master1   Ready      <none>   5d      v1.20.4
k8s-master2   NotReady   <none>   4d22h   v1.20.4
k8s-node1     Ready      <none>   4d23h   v1.20.4
k8s-node2     Ready      <none>   4d23h   v1.20.4



#master1利用yaml文件创建pod
[root@k8s-master1 ~]# vim nginx-dep.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
 name: nginx-dep
spec:
 selector:
   matchLabels:
     app: nginx
 replicas: 2
 template:
   metadata:
     labels:
       app: nginx
   spec:
     containers:
     - name: nginx
       image: daocloud.io/library/nginx:1.12.0-alpine
       ports:
       - containerPort: 80


[root@k8s-master1 ~]# kubectl apply -f nginx-dep.yaml 
deployment.apps/nginx-dep created


#查看创建出来的pod
[root@k8s-master1 ~]# kubectl get pod
NAME                        READY   STATUS    RESTARTS   AGE
nginx-dep-86df8bbd5-ckb9q   1/1     Running   0          4m14s
nginx-dep-86df8bbd5-cqpcw   1/1     Running   0          4m14s

#查看产生的deployment
[root@k8s-master1 ~]# kubectl get deploy
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
nginx-dep   2/2     2            2           4m36s



测试结果，在master2宕机的情况下，master1仍能管理k8s集群
```

## 2、宕机master

```shell
模拟宕机master1


[root@k8s-master2 cfg]# kubectl get node
NAME          STATUS     ROLES    AGE    VERSION
k8s-master1   NotReady   <none>   5d2h   v1.20.4
k8s-master2   Ready      <none>   5d     v1.20.4
k8s-node1     Ready      <none>   5d1h   v1.20.4
k8s-node2     Ready      <none>   5d1h   v1.20.4


#查看默认命名空间下的pod，发现先前宕机master2时，master1创建的pod，以及deployment
[root@k8s-master2 cfg]# kubectl get pod
NAME                        READY   STATUS    RESTARTS   AGE
nginx-dep-86df8bbd5-ckb9q   1/1     Running   0          97m
nginx-dep-86df8bbd5-cqpcw   1/1     Running   0          97m

[root@k8s-master2 cfg]# kubectl get deploy
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
nginx-dep   2/2     2            2           98m


#master2删除之前master1创建的pod、deployment
[root@k8s-master2 cfg]# kubectl delete deploy nginx-dep
deployment.apps "nginx-dep" deleted
[root@k8s-master2 cfg]# kubectl get deploy
No resources found in default namespace.

[root@k8s-master2 cfg]# kubectl get pod
No resources found in default namespace.
```

## 3、重启master1

```shell
#查看node状态
[root@k8s-master1 ~]# kubectl get node
NAME          STATUS   ROLES    AGE    VERSION
k8s-master1   Ready    <none>   5d2h   v1.20.4
k8s-master2   Ready    <none>   5d     v1.20.4
k8s-node1     Ready    <none>   5d1h   v1.20.4
k8s-node2     Ready    <none>   5d1h   v1.20.4


#重新构建之前master2删除的项目
[root@k8s-master1 ~]# kubectl apply -f nginx-dep.yaml 
deployment.apps/nginx-dep created

[root@k8s-master1 ~]# kubectl get deploy
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
nginx-dep   2/2     2            2           18s

[root@k8s-master1 ~]# kubectl get pod
NAME                        READY   STATUS    RESTARTS   AGE
nginx-dep-86df8bbd5-s8dgq   1/1     Running   0          32s
nginx-dep-86df8bbd5-w5sb8   1/1     Running   0          32s



#master2查看
[root@k8s-master2 cfg]# kubectl get pod
NAME                        READY   STATUS    RESTARTS   AGE
nginx-dep-86df8bbd5-s8dgq   1/1     Running   0          64s
nginx-dep-86df8bbd5-w5sb8   1/1     Running   0          64s

[root@k8s-master2 cfg]# kubectl get deploy
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
nginx-dep   2/2     2            2           100s


一切正常！！！
```

