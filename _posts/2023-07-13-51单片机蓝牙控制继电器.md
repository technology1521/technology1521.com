[toc]



51 单片机是一种常用的微控制器，它具有广泛的应用领域。本篇博客将介绍如何利用 51 单片机和蓝牙模块来实现对继电器的远程控制。

# 一些“废话”

>﻿﻿前言：作者想要帮助一些童鞋和爱好者进行项目构建，但自知能力有限，不喜可论，创作不易，勿喷。

> 系统由STC89C51单片机、4路继电器、蓝牙模块及电源组成。
> 可以说是一个非常简单的设计，但这里我来说明一些内容。
> 第一，项目第一步我们应该干什么？
> 画图？写程序？还是画仿真？这些都不是。我认为第一步应该清楚我们需要干什么，这是画图，写程序之前需要理解的。
> 第二，我们做这些需要用到什么？这其中包括软件需要用到什么硬件需要用到什么，还有相应的单片机端口应该怎样选择？
> 第三，如果我们想要做成这个东西，那么我们中间遇到问题应该怎么办？需要哪些平台？

> 针对这三个问题，我一一来解答，对于这个系统来说：
> 第一，我们需要干什么？
> 从设计要求来看，就是利用蓝牙模块来控制4个继电器的开断。
> 好，那么问题就来了。蓝牙是否能够直接控制继电器，如同esp8266一样？答案显然是不能的。那么蓝牙要通过单片机控制继电器。现在我们就有一个很简单的一个模型。

> 手机蓝牙 (通信) ==>  板载蓝牙 （通信） ==>  STC89C51单片机（控制）  ==>继电器;
> 当然继电器模型后面还可以跟其他外设，但是我们这里就不继续添加，理解好电气原理即可。
> 第二，我们需要用到什么？
> 软件方面
> 编程软件  keil4 
> 烧录软件 stc-isp-15xx-v6.86q.exe
> 链接：https://pan.baidu.com/s/1hsGnfBAvfWlGXgPjhYXsyg 
> 提取码：6666 
> 画图软件  AD20
> 链接：https://pan.baidu.com/s/1Fyxh-PHZftNI1HIAMSTZPw 
> 提取码：6666 
> 这个工程无法仿真模拟，所以没有仿真

## 所需硬件和软件

- 51 单片机开发板（如 STC89C52）
- 蓝牙串口模块（如 HC-05 或 HC-06）
- 继电器模块
- USB 转 TTL 串口模块
- Keil C 语言集成开发环境

## 硬件连接

1. 连接蓝牙模块和 51 单片机开发板：

   - 将蓝牙模块的 VCC 引脚连接到 5V 电源，GND 引脚连接到 GND，TX 引脚连接到单片机的 P3.0 引脚，RX 引脚连接到单片机的 P3.1 引脚。
   - 注意：如果你使用的是 HC-05 蓝牙模块，请将 EN 引脚连接到 VCC。如果你使用的是 HC-06 蓝牙模块，则不需要连接 EN 引脚。

2. 连接继电器模块和 51 单片机开发板：

   - 将继电器模块的 VCC 引脚连接到 5V 电源，GND 引脚连接到 GND，IN1 引脚连接到单片机的 P1.0 引脚、IN2 引脚连接到单片机的 P1.1 引脚、IN3引脚连接到单片机的 P1.2 引脚、IN4 引脚连接到单片机的 P1.3引脚。

3. 将 USB 转 TTL 串口模块连接到单片机的 UART0 引脚（RXD0 和 TXD0），用于调试和程序下载。

4. 元器件表格
   ![元器件清单](https://img-blog.csdnimg.cn/20210617011940317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA0NDQy,size_16,color_FFFFFF,t_70)


   购买器件可以选择淘宝、[立创商城](https://www.szlcsc.com/?c=BD)等。
   打板子
   可以在嘉立创或捷配。（两家都行，仁者见仁）
   第三 遇到了问题可以参考csdn、51黑电子论坛等。当然如果在学校老师是不二之选。

   第一步树立思路已经好了，第二步就是画图，刚刚说了，画图用AD20，但是有一些库我们是没有的，除了自己构建库之外，以下两个网站也是很好的途径。
   [PCBlib](https://www.pcblibraries.com/Default.asp)
   [AD官网](https://www.altium.com/)

   ## 原理图

   ![原理图](https://img-blog.csdnimg.cn/20210617010717933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA0NDQy,size_16,color_FFFFFF,t_70)

   ## PCB

   ![PCB](https://img-blog.csdnimg.cn/20210617011432331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA0NDQy,size_16,color_FFFFFF,t_70)

   

   ## 实物图

   图已经画好了，送去打板焊接之后。

   

   ![实物图](https://img-blog.csdnimg.cn/20210617011640474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzA0NDQy,size_16,color_FFFFFF,t_70)

### 软件开发

1. 在 Keil C 语言集成开发环境中创建一个新的工程。
2. 编写程序来控制蓝牙和继电器：
   - 初始化串口，设置波特率为 9600。
   - 通过串口与蓝牙模块通信，接收来自手机的指令。
   - 根据接收到的指令控制继电器的开关状态。
   - 将程序烧录到 51 单片机开发板中。
3. 通过手机应用程序与蓝牙模块进行通信：
   - 下载并安装一个蓝牙串口调试工具，如 Arduino Bluetooth Controller 或者 BlueTerm。
   - 打开应用程序，并连接到蓝牙模块。
   - 在应用程序中发送指令来控制继电器的开关状态。

## 源代码

```c
#include <reg52.h> 
#include <intrins.h>
#include <stdio.h>
#include "delay.h"
//	操作方法
// 蓝牙发送字符 CX或cX 表示关闭x位灯， x取值1-8	 
// 蓝牙发送字符 OX或oX 表示关闭x位灯， x取值1-8

#define INIT 0xFF	   //定义常量
#define OPEN 0x22
#define CLOSE 0x33

unsigned long times_5ms=0;	   //定时计数
unsigned char Commd_Flag=INIT;		  //初始化命令接收标志
	  
sbit relay1=P1^0;	  	//初始化relay对应引脚
sbit relay2=P1^1;
sbit relay3=P1^2;
sbit relay4=P1^3;
sbit relay5=P1^4;
sbit relay6=P1^5;
sbit relay7=P1^6;
sbit relay8=P1^7;

void Init_Timer0(void);//定时器初始化

void UART_Init(void);			 //函数声明
void SendByte(unsigned char dat);
void SendStr(unsigned char *s,unsigned char length);

void main (void)
{

	Init_Timer0();        //定时器0初始化
	UART_Init();		   //蓝牙 串口 波特率9600

	P1=0x00;
	DelayMs(200);          //延时有助于稳定	 上电检测下硬件
	P1=0xff;
	
	while(1)         //主循环
	{
			;//蓝牙的接收处理 均在中断中处理 请查看串口中断
	}
}

void Init_Timer0(void)
{
//**All notes can be deleted and modified**//
  TMOD |= 0x10;	  //使用模式1，16位定时器，使用"|"符号可以在使用多个定时器时不受影响		     
	TH0=(65536-10000)/256;		  //重新赋值 20ms
	TL0=(65536-10000)%256;
	EA=1;            //总中断打开
	ET0=1;           //定时器中断打开
	TR0=1;           //定时器开关打开
}
void UART_Init(void)
{
//**All notes can be deleted and modified**//
    SCON  = 0x05;		        // SCON: 模式 1, 8-bit UART, 使能接收  
    TMOD |= 0x20;               // TMOD: timer 1, mode 2, 8-bit 重装
    TH1   = 0xFD;               // TH1:  重装值 9600 波特率 晶振 11.0592MHz
	TL1 = TH1;  
    TR1   = 1;                  // TR1:  timer 1 打开                         
    EA    = 1;                  //打开总中断
    ES    = 1;                  //打开串口中断
} 

void Timer0_isr(void) interrupt 1 
{
	TH0=(65536-5000)/256;		  //重新赋值 5ms
	TL0=(65536-5000)%256;
	times_5ms++;				  //定时5ms

}

void UART_SER (void) interrupt 4 	//串行中断服务程序
{
	unsigned char R_buf;
	if(RI)                        //判断是接收中断产生
	{
		RI=0;                      //标志位清零
		R_buf=SBUF;
		if((R_buf=='O')||(R_buf=='o'))
		{
			Commd_Flag=OPEN;	//接收到打开灯标志
		}
		else if((R_buf=='C')&&(R_buf=='c'))
		{
			Commd_Flag=CLOSE;	//接收到 关闭灯标志
		}
		else if((R_buf!='1')&&(R_buf!='2')&&(R_buf!='3')&&(R_buf!='4')&&(R_buf!='5')&&(R_buf!='6')&&(R_buf!='7')&&(R_buf!='8')&&(R_buf!='a')&&(R_buf!='A'))
		{
			Commd_Flag=INIT;	 //否则 初始化接受标志
		}

		if(Commd_Flag==OPEN)			//根据命令值进行打开相应的灯
		{
			switch(R_buf)
			{
				case '1':relay1=0;Commd_Flag=INIT;break;	//打开相应的灯 并恢复命令标志
				case '2':relay2=0;Commd_Flag=INIT;break;			
				case '3':relay3=0;Commd_Flag=INIT;break;			
				case '4':relay4=0;Commd_Flag=INIT;break;			
				case '5':relay5=0;Commd_Flag=INIT;break;	
				case '6':relay6=0;Commd_Flag=INIT;break;			
				case '7':relay7=0;Commd_Flag=INIT;break;			
				case '8':relay8=0;Commd_Flag=INIT;break;
				case 'A':relay1=0;relay2=0;relay3=0;relay4=0;relay5=0;relay6=0;relay7=0;relay8=0;Commd_Flag=INIT;break;
				case 'a':relay1=0;relay2=0;relay3=0;relay4=0;relay5=0;relay6=0;relay7=0;relay8=0;Commd_Flag=INIT;break;
				default:break;						 //此处错误判断 不可恢复命令标准
			}
		}
		else if(Commd_Flag==CLOSE)//根据命令值进行关闭相应的灯
		{
			switch(R_buf)
			{
				case '1':relay1=1;Commd_Flag=INIT;break;	//关闭相应的灯 并恢复命令标志
				case '2':relay2=1;Commd_Flag=INIT;break;			
				case '3':relay3=1;Commd_Flag=INIT;break;			
				case '4':relay4=1;Commd_Flag=INIT;break;			
				case '5':relay5=1;Commd_Flag=INIT;break;	
				case '6':relay6=1;Commd_Flag=INIT;break;			
				case '7':relay7=1;Commd_Flag=INIT;break;			
				case '8':relay8=1;Commd_Flag=INIT;break;
				case 'A':relay1=1;relay2=1;relay3=1;relay4=1;relay5=1;relay6=1;relay7=1;relay8=1;Commd_Flag=INIT;break;
				case 'a':relay1=1;relay2=1;relay3=1;relay4=1;relay5=1;relay6=1;relay7=1;relay8=1;Commd_Flag=INIT;break;					
				default:break;						 //此处错误判断 不可恢复命令标准
			}
		}
		SBUF=R_buf;				   //返回接收到的数据
	}
	if(TI)  //如果是发送标志位，清零
	TI=0;
} 
```

代码书写完成后，通过烧录软件烧录hex文件，可以进行板子运行。

## 测试

手机蓝牙连接，下载我所上传的蓝牙软件。即可匹配板载蓝牙。通过相应指令进行蓝牙信息通信，进而控制继电器。

### 结论

通过使用 51 单片机和蓝牙模块，你可以实现对继电器的远程控制。本篇博客提供了基本的硬件连接和示例代码，帮助你快速入门并构建自己的蓝牙控制继电器应用。

希望这篇博客对你有所帮助！如有其他问题，请随时提问或参考相关文档和资源。

详细内容下载地址
https://download.csdn.net/download/qq_42704442/19694907?spm=1001.2014.3001.5501
秉承思想开源劳动收费的原则，可能会收取少量积分或者金钱。如果需要实物，或者产品定制，皆可私聊。



